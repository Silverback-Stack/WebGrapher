<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Sigma.js + Graphology.js example</title>
    <script type="importmap">
        {
          "imports": {
            "sigma": "https://cdnjs.cloudflare.com/ajax/libs/sigma.js/3.0.0/sigma.min.js",
            "graphology": "https://cdn.jsdelivr.net/npm/graphology@0.26.0/dist/graphology.umd.min.js",
            "graphologyLibrary": "https://cdn.jsdelivr.net/npm/graphology-library@0.8.0/browser.min.js"
          }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/microsoft-signalr/9.0.6/signalr.min.js"></script>
</head>

<body style="background: lightgrey">
    <div id="container" style="width: 600px; height: 600px; background: white"></div>
    <script type="module">
        import * as sigma from 'sigma';
        import 'graphology'; // has no exports, import all
        import 'graphologyLibrary'; // has no exports, import all

        // Create an empty graph
        const graph = new graphology.Graph();

        //// Infer settings from graph & assign
        //const settings = graphologyLibrary.layoutForceAtlas2.inferSettings(graph);
        //graphologyLibrary.layoutForceAtlas2.assign(graph, {
        //    iterations: 50,
        //    settings: settings
        //});

        // Instantiate sigma.js and render the graph
        const sigmaInstance = new Sigma(graph, document.getElementById("container"));

        // Add or update nodes from server
        function upsertNodes(nodes) {
            nodes.forEach(node => {
                if (graph.hasNode(node.id)) {
                    // Update existing node attributes (overwrite)
                    graph.setNodeAttribute(node.id, "label", node.label);
                    graph.setNodeAttribute(node.id, "size", node.size);
                    graph.setNodeAttribute(node.id, "color", pickColor(node.state));
                    // Update any other attributes you want to keep consistent here
                } else {
                    // Add new node
                    graph.addNode(node.id, {
                        label: node.label,
                        size: node.size,
                        color: pickColor(node.state),
                        x: Math.random(),
                        y: Math.random()
                    });
                }
            });
        }

        // Remove all edges where source = nodeId
        function removeEdgesFromNode(nodeId) {
            // Collect edges to remove
            const edgesToRemove = [];
            graph.forEachEdge((edgeId, attributes) => {
                if (attributes.source === nodeId) {
                    edgesToRemove.push(edgeId);
                }
            });
            edgesToRemove.forEach(eid => graph.dropEdge(eid));
        }

        // Add edges, ignoring duplicates
        function addEdges(edges) {
            edges.forEach(edge => {
                if (!graph.hasEdge(edge.id)) {
                    graph.addEdge(edge.id, edge.source, edge.target, {
                        size: 1,
                        color: "#ccc"
                    });
                }
            });
        }

        // Main function to process server payload for a single node and its outgoing links
        function renderWebNodePayload(payload) {
            if (!payload || !payload.nodes || !payload.edges) return;

            // Upsert all nodes in payload (main node + outgoing links)
            upsertNodes(payload.nodes);

            // We assume first node in payload.nodes is the main node whose edges to replace
            const mainNodeId = payload.nodes[0]?.id;
            if (!mainNodeId) return;

            // Remove old outgoing edges from main node
            removeEdgesFromNode(mainNodeId);

            // Add fresh edges from payload
            addEdges(payload.edges);

            // Refresh Sigma rendering (assuming you have a sigma instance)
            sigmaInstance.refresh();
        }

        // Simple color map by state
        function pickColor(state) {
            switch (state) {
                case "Populated": return "green";
                case "Dummy": return "blue";
                case "Redirected": return "red";
                default: return "gray";
            }
        }

        // Connect to SignalR hub
        const graphId = 1; // Example â€” match your group join logic on server
        const connection = new signalR.HubConnectionBuilder()
            .withUrl("http://localhost:5001/graphStreamerHub")
            .configureLogging(signalR.LogLevel.Information)
            .build();

        connection.on("ReceiveWebNode", (webNode) => {
            console.log("Received node:", webNode);
            renderWebNodePayload({
                nodes: webNode.nodes,
                edges: webNode.edges
            });
        });

        connection.on("ReceiveMessage", (message) => {
            console.log("Received message:", message);
        });

        async function startConnection() {
            try {
                await connection.start();
                console.log("SignalR connected.");
                await connection.invoke("JoinGraphGroup", graphId.toString()); // assuming your hub has this
            } catch (err) {
                console.error(err);
                setTimeout(startConnection, 5000);
            }
        }

        startConnection();
    </script>
</body>

</html>